#!/usr/bin/env python3
"""
Mauritania Eye - Vulnerability Scanner Module
Web application and network vulnerability assessment

Author: Mohamed Lemine Ahmed Jidou üá≤üá∑
"""

import asyncio
import subprocess
import json
import re
from datetime import datetime
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress

class VulnerabilityScanner:
    """
    Vulnerability scanning and assessment module
    """
    
    def __init__(self, logger):
        self.logger = logger
        self.console = Console()
        self.vulnerabilities = []
        
    async def scan_targets(self, hosts):
        """Scan multiple targets for vulnerabilities"""
        self.console.print(Panel("üõ°Ô∏è Starting Vulnerability Assessment", style="bold red"))
        
        all_vulnerabilities = []
        
        with Progress() as progress:
            task = progress.add_task("Scanning targets...", total=len(hosts))
            
            for host in hosts:
                host_vulns = await self._scan_single_target(host['ip'])
                if host_vulns:
                    all_vulnerabilities.extend(host_vulns)
                progress.advance(task)
        
        # Generate report
        await self._generate_vulnerability_report(all_vulnerabilities)
        
        return all_vulnerabilities
    
    async def _scan_single_target(self, target):
        """Scan a single target for vulnerabilities"""
        vulnerabilities = []
        
        # Check if target has web services
        web_ports = [80, 443, 8080, 8443]
        open_web_ports = await self._check_web_services(target, web_ports)
        
        if open_web_ports:
            # Run Nikto scan
            nikto_results = await self._run_nikto_scan(target, open_web_ports)
            vulnerabilities.extend(nikto_results)
            
            # Run custom web vulnerability checks
            custom_vulns = await self._run_custom_web_checks(target, open_web_ports)
            vulnerabilities.extend(custom_vulns)
        
        # Run network-level vulnerability checks
        network_vulns = await self._run_network_vulnerability_checks(target)
        vulnerabilities.extend(network_vulns)
        
        return vulnerabilities
    
    async def _check_web_services(self, target, ports):
        """Check which web service ports are open"""
        open_ports = []
        
        for port in ports:
            try:
                # Use nmap to check if port is open
                result = subprocess.run(
                    ['nmap', '-p', str(port), '--open', target],
                    capture_output=True, text=True, timeout=30
                )
                
                if f"{port}/tcp open" in result.stdout:
                    open_ports.append(port)
                    
            except Exception as e:
                self.logger.log_error("VulnerabilityScanner", f"Error checking port {port} on {target}: {str(e)}")
        
        return open_ports
    
    async def _run_nikto_scan(self, target, ports):
        """Run Nikto vulnerability scanner"""
        vulnerabilities = []
        
        for port in ports:
            try:
                protocol = "https" if port in [443, 8443] else "http"
                url = f"{protocol}://{target}:{port}"
                
                self.console.print(f"[yellow]Running Nikto scan on {url}[/yellow]")
                
                # Run Nikto
                result = subprocess.run(
                    ['nikto', '-h', url, '-Format', 'json', '-output', '-'],
                    capture_output=True, text=True, timeout=300
                )
                
                if result.returncode == 0:
                    nikto_vulns = self._parse_nikto_output(result.stdout, target, port)
                    vulnerabilities.extend(nikto_vulns)
                
            except subprocess.TimeoutExpired:
                self.logger.log_warning("VulnerabilityScanner", f"Nikto scan timeout for {target}:{port}")
            except Exception as e:
                self.logger.log_error("VulnerabilityScanner", f"Nikto scan error for {target}:{port}: {str(e)}")
        
        return vulnerabilities
    
    def _parse_nikto_output(self, output, target, port):
        """Parse Nikto JSON output"""
        vulnerabilities = []
        
        try:
            # Nikto output might not be valid JSON, so we'll parse line by line
            lines = output.split('\n')
            for line in lines:
                if 'OSVDB' in line or 'CVE' in line or 'vulnerability' in line.lower():
                    vuln = {
                        'target': target,
                        'port': port,
                        'scanner': 'nikto',
                        'timestamp': datetime.now().isoformat(),
                        'severity': self._assess_severity(line),
                        'description': line.strip(),
                        'type': 'web_vulnerability'
                    }
                    vulnerabilities.append(vuln)
                    
        except Exception as e:
            self.logger.log_error("VulnerabilityScanner", f"Error parsing Nikto output: {str(e)}")
        
        return vulnerabilities
    
    async def _run_custom_web_checks(self, target, ports):
        """Run custom web vulnerability checks"""
        vulnerabilities = []
        
        for port in ports:
            protocol = "https" if port in [443, 8443] else "http"
            base_url = f"{protocol}://{target}:{port}"
            
            # Check for common vulnerabilities
            checks = [
                self._check_directory_traversal,
                self._check_sql_injection,
                self._check_xss_vulnerability,
                self._check_default_credentials,
                self._check_information_disclosure
            ]
            
            for check in checks:
                try:
                    result = await check(base_url)
                    if result:
                        result.update({
                            'target': target,
                            'port': port,
                            'scanner': 'custom',
                            'timestamp': datetime.now().isoformat()
                        })
                        vulnerabilities.append(result)
                except Exception as e:
                    self.logger.log_error("VulnerabilityScanner", f"Custom check error: {str(e)}")
        
        return vulnerabilities
    
    async def _check_directory_traversal(self, base_url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
        ]
        
        for payload in payloads:
            try:
                # Use curl to test
                result = subprocess.run(
                    ['curl', '-s', '-k', f"{base_url}/{payload}"],
                    capture_output=True, text=True, timeout=10
                )
                
                if "root:" in result.stdout or "administrator" in result.stdout.lower():
                    return {
                        'type': 'directory_traversal',
                        'severity': 'high',
                        'description': f"Directory traversal vulnerability detected with payload: {payload}",
                        'evidence': result.stdout[:200]
                    }
                    
            except Exception:
                continue
        
        return None
    
    async def _check_sql_injection(self, base_url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "1' OR '1'='1' --",
            "1' UNION SELECT NULL--"
        ]
        
        for payload in payloads:
            try:
                # Test common parameters
                test_urls = [
                    f"{base_url}/?id={payload}",
                    f"{base_url}/login?username={payload}&password=test"
                ]
                
                for url in test_urls:
                    result = subprocess.run(
                        ['curl', '-s', '-k', url],
                        capture_output=True, text=True, timeout=10
                    )
                    
                    # Look for SQL error messages
                    sql_errors = [
                        "mysql_fetch_array",
                        "ORA-01756",
                        "Microsoft OLE DB Provider",
                        "SQLServer JDBC Driver"
                    ]
                    
                    for error in sql_errors:
                        if error.lower() in result.stdout.lower():
                            return {
                                'type': 'sql_injection',
                                'severity': 'critical',
                                'description': f"SQL injection vulnerability detected with payload: {payload}",
                                'evidence': error
                            }
                            
            except Exception:
                continue
        
        return None
    
    async def _check_xss_vulnerability(self, base_url):
        """Check for XSS vulnerabilities"""
        payload = "<script>alert('XSS')</script>"
        
        try:
            result = subprocess.run(
                ['curl', '-s', '-k', f"{base_url}/?q={payload}"],
                capture_output=True, text=True, timeout=10
            )
            
            if payload in result.stdout:
                return {
                    'type': 'xss',
                    'severity': 'medium',
                    'description': "Reflected XSS vulnerability detected",
                    'evidence': payload
                }
                
        except Exception:
            pass
        
        return None
    
    async def _check_default_credentials(self, base_url):
        """Check for default credentials"""
        default_creds = [
            ("admin", "admin"),
            ("admin", "password"),
            ("root", "root"),
            ("admin", ""),
            ("", "admin")
        ]
        
        for username, password in default_creds:
            try:
                # Try basic auth
                result = subprocess.run(
                    ['curl', '-s', '-k', '-u', f"{username}:{password}", f"{base_url}/admin"],
                    capture_output=True, text=True, timeout=10
                )
                
                if result.returncode == 0 and "401" not in result.stdout:
                    return {
                        'type': 'default_credentials',
                        'severity': 'high',
                        'description': f"Default credentials found: {username}:{password}",
                        'evidence': f"Authentication successful with {username}:{password}"
                    }
                    
            except Exception:
                continue
        
        return None
    
    async def _check_information_disclosure(self, base_url):
        """Check for information disclosure"""
        sensitive_files = [
            "/.env",
            "/config.php",
            "/wp-config.php",
            "/web.config",
            "/.git/config",
            "/robots.txt"
        ]
        
        for file_path in sensitive_files:
            try:
                result = subprocess.run(
                    ['curl', '-s', '-k', f"{base_url}{file_path}"],
                    capture_output=True, text=True, timeout=10
                )
                
                # Check for sensitive information
                sensitive_patterns = [
                    r"password\s*=",
                    r"api_key\s*=",
                    r"secret\s*=",
                    r"database.*password"
                ]
                
                for pattern in sensitive_patterns:
                    if re.search(pattern, result.stdout, re.IGNORECASE):
                        return {
                            'type': 'information_disclosure',
                            'severity': 'medium',
                            'description': f"Sensitive information disclosed in {file_path}",
                            'evidence': result.stdout[:200]
                        }
                        
            except Exception:
                continue
        
        return None
    
    async def _run_network_vulnerability_checks(self, target):
        """Run network-level vulnerability checks"""
        vulnerabilities = []
        
        # Check for common network vulnerabilities
        checks = [
            self._check_ssh_vulnerabilities,
            self._check_ftp_vulnerabilities,
            self._check_smb_vulnerabilities,
            self._check_ssl_vulnerabilities
        ]
        
        for check in checks:
            try:
                result = await check(target)
                if result:
                    result.update({
                        'target': target,
                        'scanner': 'network_check',
                        'timestamp': datetime.now().isoformat()
                    })
                    vulnerabilities.append(result)
            except Exception as e:
                self.logger.log_error("VulnerabilityScanner", f"Network check error: {str(e)}")
        
        return vulnerabilities
    
    async def _check_ssh_vulnerabilities(self, target):
        """Check for SSH vulnerabilities"""
        try:
            # Check if SSH is running
            result = subprocess.run(
                ['nmap', '-p', '22', '--script', 'ssh-auth-methods', target],
                capture_output=True, text=True, timeout=30
            )
            
            if "22/tcp open" in result.stdout:
                if "password" in result.stdout and "publickey" not in result.stdout:
                    return {
                        'type': 'ssh_weak_auth',
                        'port': 22,
                        'severity': 'medium',
                        'description': "SSH allows password authentication without public key requirement"
                    }
                    
        except Exception:
            pass
        
        return None
    
    async def _check_ftp_vulnerabilities(self, target):
        """Check for FTP vulnerabilities"""
        try:
            result = subprocess.run(
                ['nmap', '-p', '21', '--script', 'ftp-anon', target],
                capture_output=True, text=True, timeout=30
            )
            
            if "Anonymous FTP login allowed" in result.stdout:
                return {
                    'type': 'ftp_anonymous_access',
                    'port': 21,
                    'severity': 'high',
                    'description': "FTP allows anonymous access"
                }
                
        except Exception:
            pass
        
        return None
    
    async def _check_smb_vulnerabilities(self, target):
        """Check for SMB vulnerabilities"""
        try:
            result = subprocess.run(
                ['nmap', '-p', '445', '--script', 'smb-vuln-*', target],
                capture_output=True, text=True, timeout=60
            )
            
            if "VULNERABLE" in result.stdout:
                return {
                    'type': 'smb_vulnerability',
                    'port': 445,
                    'severity': 'critical',
                    'description': "SMB vulnerability detected",
                    'evidence': result.stdout
                }
                
        except Exception:
            pass
        
        return None
    
    async def _check_ssl_vulnerabilities(self, target):
        """Check for SSL/TLS vulnerabilities"""
        try:
            result = subprocess.run(
                ['nmap', '-p', '443', '--script', 'ssl-enum-ciphers', target],
                capture_output=True, text=True, timeout=30
            )
            
            if "SSLv2" in result.stdout or "SSLv3" in result.stdout:
                return {
                    'type': 'ssl_weak_protocol',
                    'port': 443,
                    'severity': 'high',
                    'description': "Weak SSL/TLS protocol versions enabled"
                }
                
        except Exception:
            pass
        
        return None
    
    def _assess_severity(self, description):
        """Assess vulnerability severity based on description"""
        description_lower = description.lower()
        
        if any(word in description_lower for word in ['critical', 'remote code execution', 'sql injection']):
            return 'critical'
        elif any(word in description_lower for word in ['high', 'authentication bypass', 'privilege escalation']):
            return 'high'
        elif any(word in description_lower for word in ['medium', 'information disclosure', 'xss']):
            return 'medium'
        else:
            return 'low'
    
    async def _generate_vulnerability_report(self, vulnerabilities):
        """Generate comprehensive vulnerability report"""
        if not vulnerabilities:
            self.console.print("[green]No vulnerabilities detected[/green]")
            return
        
        # Sort by severity
        severity_order = {'critical': 0, 'high': 1, 'medium': 2, 'low': 3}
        vulnerabilities.sort(key=lambda x: severity_order.get(x['severity'], 4))
        
        # Display summary
        self._display_vulnerability_summary(vulnerabilities)
        
        # Save detailed report
        report = {
            'timestamp': datetime.now().isoformat(),
            'total_vulnerabilities': len(vulnerabilities),
            'severity_breakdown': self._get_severity_breakdown(vulnerabilities),
            'vulnerabilities': vulnerabilities
        }
        
        await self.logger.save_report(report, "vulnerability_assessment")
    
    def _display_vulnerability_summary(self, vulnerabilities):
        """Display vulnerability assessment summary"""
        self.console.print(Panel("üö® Vulnerability Assessment Results", style="bold red"))
        
        # Severity breakdown
        severity_counts = self._get_severity_breakdown(vulnerabilities)
        
        summary_table = Table(title="Severity Breakdown")
        summary_table.add_column("Severity", style="cyan")
        summary_table.add_column("Count", style="yellow")
        summary_table.add_column("Percentage", style="green")
        
        total = len(vulnerabilities)
        for severity, count in severity_counts.items():
            percentage = (count / total * 100) if total > 0 else 0
            color = self._get_severity_color(severity)
            summary_table.add_row(
                f"[{color}]{severity.upper()}[/{color}]",
                str(count),
                f"{percentage:.1f}%"
            )
        
        self.console.print(summary_table)
        
        # Detailed vulnerabilities
        if vulnerabilities:
            vuln_table = Table(title="Detected Vulnerabilities")
            vuln_table.add_column("Target", style="cyan")
            vuln_table.add_column("Type", style="yellow")
            vuln_table.add_column("Severity", style="red")
            vuln_table.add_column("Description", style="white")
            
            for vuln in vulnerabilities[:10]:  # Show top 10
                color = self._get_severity_color(vuln['severity'])
                vuln_table.add_row(
                    vuln['target'],
                    vuln['type'],
                    f"[{color}]{vuln['severity'].upper()}[/{color}]",
                    vuln['description'][:50] + "..." if len(vuln['description']) > 50 else vuln['description']
                )
            
            self.console.print(vuln_table)
    
    def _get_severity_breakdown(self, vulnerabilities):
        """Get breakdown of vulnerabilities by severity"""
        breakdown = {'critical': 0, 'high': 0, 'medium': 0, 'low': 0}
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'low')
            if severity in breakdown:
                breakdown[severity] += 1
        
        return breakdown
    
    def _get_severity_color(self, severity):
        """Get color for severity level"""
        colors = {
            'critical': 'bright_red',
            'high': 'red',
            'medium': 'yellow',
            'low': 'blue'
        }
        return colors.get(severity, 'white')
    
    async def interactive_scan(self):
        """Interactive vulnerability scanning mode"""
        self.console.print(Panel("üõ°Ô∏è Interactive Vulnerability Scanner", style="bold red"))
        
        target = self.console.input("[yellow]Enter target IP or hostname: [/yellow]")
        if not target:
            self.console.print("[red]No target specified[/red]")
            return
        
        scan_type = self.console.input(
            "[cyan]Select scan type:\n"
            "1. Quick Web Scan\n"
            "2. Comprehensive Scan\n"
            "3. Network Vulnerability Scan\n"
            "Choice (1-3): [/cyan]"
        )
        
        if scan_type == "1":
            # Quick web scan
            web_ports = await self._check_web_services(target, [80, 443, 8080])
            if web_ports:
                vulns = await self._run_custom_web_checks(target, web_ports)
                await self._generate_vulnerability_report(vulns)
            else:
                self.console.print("[yellow]No web services detected[/yellow]")
        
        elif scan_type == "2":
            # Comprehensive scan
            vulns = await self._scan_single_target(target)
            await self._generate_vulnerability_report(vulns)
        
        elif scan_type == "3":
            # Network vulnerability scan
            vulns = await self._run_network_vulnerability_checks(target)
            await self._generate_vulnerability_report(vulns)
        
        else:
            self.console.print("[red]Invalid choice[/red]")